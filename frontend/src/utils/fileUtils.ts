import { VisualizationData, MetricDimensionality } from '../types';
import Npyjs from 'npyjs';

/**
 * Detect metric dimensionality (1D vs 2D) from visualization data
 * This is a placeholder implementation - the actual determination depends on
 * how metrics are classified in the TokEval backend
 */
export const detectMetricDimensionality = (data: VisualizationData): MetricDimensionality => {
  const result: MetricDimensionality = {};
  
  if (data.metrics) {
    Object.keys(data.metrics).forEach((metricKey) => {
      // Simple heuristic: if a metric has correlation data, it's likely 2D
      // Otherwise, it's 1D (simple scoring metric)
      const hasCorrelation = data.correlation && data.correlation[metricKey] !== undefined;
      result[metricKey] = hasCorrelation ? 2 : 1;
    });
  }
  
  return result;
};

/**
 * Load NPZ files generated by TokEval and convert them to JSON
 */
export const loadMetricsFile = async (file: File): Promise<VisualizationData> => {
  // In a real implementation, this would use a library like jszip or nippy
  // to decompress and parse NPZ files. For now, we'll handle JSON.
  // NPZ support requires additional dependencies.
  
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const content = e.target?.result as string;
        const data = JSON.parse(content);
        resolve(data);
      } catch (error) {
        reject(new Error('Failed to parse visualization file'));
      }
    };
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
};

/**
 * Extract available tokenizers from metrics data
 */
export const extractTokenizers = (data: VisualizationData): string[] => {
  const tokenizers = new Set<string>();
  if (data.metrics) {
    Object.keys(data.metrics).forEach((key) => {
      // Assuming key format: "tokenizer_metric_lang" or similar
      const parts = key.split('_');
      if (parts.length > 0) {
        tokenizers.add(parts[0]);
      }
    });
  }
  return Array.from(tokenizers);
};

/**
 * Extract available metrics from metrics data
 */
export const extractMetrics = (data: VisualizationData): string[] => {
  const metrics = new Set<string>();
  if (data.metrics) {
    Object.keys(data.metrics).forEach((key) => {
      metrics.add(key);
    });
  }
  return Array.from(metrics);
};

/**
 * Extract available languages from metrics data
 */
export const extractLanguages = (data: VisualizationData): string[] => {
  const languages = new Set<string>();
  if (data.metrics) {
    Object.keys(data.metrics).forEach((key) => {
      const parts = key.split('_');
      if (parts.length >= 3) {
        languages.add(parts[parts.length - 1]);
      }
    });
  }
  return Array.from(languages);
};

/**
 * Save visualization configuration to JSON
 */
export const saveVisualization = (data: VisualizationData, filename: string) => {
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
};

/**
 * Load metadata from TokEval Scorer output metadata file
 * Expected format:
 * {
 *   "dataset_name": "string",
 *   "tokenizers": ["list", "of", "tokenizers"],
 *   "languages": ["list", "of", "languages"],
 *   "metrics": ["list", "of", "metric_labels"],
 *   "metrics_file": "path/to/metrics.scores.npz",
 *   "correlation_file": "path/to/correlation.scores.npz"
 * }
 */
export const loadMetadata = async (file: File): Promise<VisualizationData | null> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const content = e.target?.result as string;
        const metadata = JSON.parse(content);

        // Validate required fields
        if (!metadata.dataset_name || !Array.isArray(metadata.tokenizers) || 
            !Array.isArray(metadata.languages) || !Array.isArray(metadata.metrics)) {
          reject(new Error('Invalid metadata format. Missing required fields.'));
          return;
        }

        // Create visualization data with metadata
        const visualizationData: VisualizationData = {
          metrics: {},
          correlation: {},
          metadata: {
            datasetName: metadata.dataset_name,
            timestamp: metadata.timestamp,
            version: metadata.version,
            metricsPath: metadata.metricsPath,
            correlationPath: metadata.correlationPath,
            tokenizers: metadata.tokenizers,
            languages: metadata.languages,
            metrics: metadata.metrics,
          },
        };
        resolve(visualizationData);
      } catch (error) {
        reject(new Error('Failed to parse metadata file'));
      }
    };
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
};

/**
 * Load metrics and correlation data from a directory containing TokEval output files
 * Expects files: metrics.scores.npz (or .json) and correlation.scores.npz (or .json)
 */
export const loadFromDirectory = async (files: FileList): Promise<VisualizationData | null> => {
  let metricsData: any = null;
  let correlationData: any = null;

  // Convert FileList to Array and process
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const filename = file.name;

    if (filename.includes('metrics.scores')) {
      try {
        metricsData = await loadNpzOrJson(file);
      } catch (error) {
        console.warn('Failed to load metrics file:', error);
      }
    } else if (filename.includes('correlation.scores')) {
      try {
        correlationData = await loadNpzOrJson(file);
      } catch (error) {
        console.warn('Failed to load correlation file:', error);
      }
    }
  }

  if (metricsData || correlationData) {
    return {
      metrics: metricsData || {},
      correlation: correlationData || {},
    };
  }

  throw new Error('No valid metrics or correlation files found in directory');
};

/**
 * Load NPZ or JSON file
 * For now, handles JSON; NPZ support requires additional dependencies
 */
const loadNpzOrJson = async (file: File): Promise<any> => {
  if (file.name.endsWith('.json')) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const content = e.target?.result as string;
          resolve(JSON.parse(content));
        } catch (error) {
          reject(new Error('Failed to parse JSON file'));
        }
      };
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  } else if (file.name.endsWith('.npz')) {
    // Use npyjs to parse npz file in browser
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const npz = new Npyjs();
          const buffer = e.target?.result as ArrayBuffer;
          const arrays = await npz.load(buffer) as Record<string, any>;
          // Convert all arrays to plain JS arrays
          const out: Record<string, any> = {};
          for (const key in arrays) {
            if (Object.prototype.hasOwnProperty.call(arrays, key)) {
              const arr = arrays[key];
              out[key] = arr.data ? Array.from(arr.data) : arr;
            }
          }
          resolve(out);
        } catch (error) {
          reject(new Error('Failed to parse NPZ file: ' + error));
        }
      };
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsArrayBuffer(file);
    });
  }

  throw new Error(`Unsupported file format: ${file.name}`);
};

/**
 * Export charts as PNG images using html2canvas
 * Note: Requires html2canvas library - install with: npm install html2canvas
 */
export const exportGraphAsPNG = async (
  elementId: string,
  filename: string
): Promise<void> => {
  // Dynamic import to avoid hard dependency
  try {
    const html2canvas = (await import('html2canvas')).default;
    const element = document.getElementById(elementId);
    
    if (!element) {
      throw new Error(`Element with ID ${elementId} not found`);
    }

    const canvas = await html2canvas(element, {
      backgroundColor: '#fff',
      scale: 2,
      logging: false,
    });

    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = filename;
    link.click();
  } catch (error) {
    console.warn('html2canvas not available. Export requires: npm install html2canvas');
    throw new Error('Graph export requires html2canvas library. Please install it first.');
  }
};

/**
 * Export all graphs as PNG files
 * Creates a list of exports and triggers download
 */
export const exportAllGraphs = async (
  graphs: Array<{ id: string; filename?: string }>
): Promise<void> => {
  if (graphs.length === 0) {
    alert('No graphs to export');
    return;
  }

  try {
    for (const graph of graphs) {
      const base = graph.filename || graph.id || 'graph';
      const safe = String(base).replace(/[^a-z0-9]/gi, '_');
      const filename = `${safe}.png`;
      await exportGraphAsPNG(graph.id, filename);
      // Add small delay between exports to avoid browser throttling
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    alert(`Successfully exported ${graphs.length} graph(s)`);
  } catch (error) {
    alert(`Failed to export graphs: ${error instanceof Error ? error.message : 'Unknown error'}`);
    console.error('Export error:', error);
  }
};
